Rebmu [
	Title: {Code Golf Bingo}
	Home: http://codegolf.stackexchange.com/a/8558/57

	Purpose: {
		You are given a Bingo board and a list of calls. You must print BINGO!
		as soon as your board wins the game.

		Bingo boards will be specified like this:

			14 29 38 52 74
			4 18 33 46 62
			7 16 * 60 71
			9 27 44 51 67
			12 23 35 47 73

		Immediately following the board will be calls, like this:

			B7
			I29
			G60
			G51
			O71
			I23
			I16
			N38

		You must echo the calls out to standard output until just after the
		call that makes you win (get a row, column, or 5-long diagonal all
		filled), then print BINGO!.

		For the above example, print:

			B7
			I29
			G60
			G51
			O71
			I23
			I16
			BINGO!

		There will always be enough calls to guarantee you a Bingo. There will
		be no duplicate numbers on the board, and no duplicate calls. Boards
		will always have correctly matched numbers and letters (the B column
		contains only 1-15, the I column contains only 16-30, and so on),
		as will calls. The one and only free space will always be in the
		middle, marked with * instead of a number. Consuming and discarding
		calls from standard input after the winning call is allowed, but not
		required.
	}

	Description: {
		This solution is based on a flattening that builds up a sequence of all
		the winning combinations into a sequence.  every fifth element
		in the sequence G represents a solution.  using the rather obvious
		trick of substituting a picked number with an asterisk, it is only
		necessary to find a series of 5 asterisks in this expanded set which
		starts on one of these boundaries.
	}
]

; store the number five since we use it a lot, s for "Size"
S05

; RepeaT this loop five times, with variable Z counting 1 to 5
rtZs[
	; a trick that helps reduce the number of loops is that the 5-line input
	; loop actually builds the diagonal solutions.  as it proceeds it inserts
	; one at the beginning and appends the other as it goes.  so if the first
	; line of your bingo board is "14 29 38 52 74", then after that input you
	; will have:
	;
	;      [14 14 29 38 52 74 74]
	;
	; if the second line of your bingo board is "4 18 33 46 62", you'll get:
	;
	;      [18 14 4 18 33 46 62 14 29 38 52 74 74 46]
	;
	; at this stage, two of the five forward diagonal numbers have been
	; inserted at the head, while two of the five reverse diagonal numbers are
	; appended at the tail.  because the series of five are checked and order
	; does not matter, the natural choice of insert and append are used.  the
	; final state will have G contain the five horizontal lines bookended by
	; the series of five values that make the diagonal
	;
	; we also build a vector of 5 asterisk literals in V, so long as we loop x5

	GisGpcRaZisGaAPgPCaSB06zAPv'*
]

; our second loop is nested, with the job of capturing the vertical winning
; solutions and appending them to the list as new sequences of 5 values.  Each
; iteration of the outer loop appends one vertical solution
lS[
	; we start by assigning A to point to G, which starts with pointing at the
	; first element of a non-diagonal row in our series.  Then we loop five
	; times to append the vertical by skipping five elements at a time
	AgLs[
		apGfAsk+aS
	]

	; we advance the G pointer to the next first element of a non-diagonal row,
	; to be copied into A and skipped by fives again.
	f+G
]

; reset G to head, and "until" the block evaluates to something true, we loop
hd+Gu[
	; this simply does a replace/all in our sequence for any occurrence of the
	; integer portion of the string we read from the user...putting an asterisk
	; in the place a number is found.  Then we just use find with a skip value
	; of 5 on the vector of asterisks we created earlier.
	raGin-NXrM'*FISgVs
]

; print bingo, 'cause we're done...
p"BINGO!"
